---
/**
 * Camera control scheme type.
 * - 'none': No user controls (pose cycling only)
 * - 'orbit': Orbit around a focus point
 * - 'fly': Free-flight movement
 * - 'both': Both modes available (default)
 */
type ControlScheme = "none" | "orbit" | "fly" | "both";

/**
 * Idle animation type.
 * - 'none': No idle animation (user has full control)
 * - 'drift-pause': Gentle hovering/drifting effect with pauses
 * - 'auto-rotate': Continuous rotation around the focus point
 */
type IdleAnimationType = "none" | "drift-pause" | "auto-rotate";

interface SplatProps {
  /** Scene name (required). */
  scene: string;

  /**
   * Where to anchor the progress panel.
   * Allowed: "center", "top-left", "top-center", "top-right", "bottom-left", "bottom-center", "bottom-right".
   */
  progressPosition?:
    | "center"
    | "top-left"
    | "top-center"
    | "top-right"
    | "bottom-left"
    | "bottom-center"
    | "bottom-right";

  /** Horizontal pixel offset from the chosen anchor (e.g., 16). */
  progressOffsetX?: number;

  /** Vertical pixel offset from the chosen anchor (e.g., 16). */
  progressOffsetY?: number;

  /** Optional absolute/relative URL for the preview image. Defaults to BASE_URL/static/<scene>/preview.webp */
  previewSrc?: string;

  /** Optional inline CSS style passed by the caller (e.g., CSS variables). */
  style?: string;

  /**
   * Camera control scheme.
   * - 'none': No user controls (pose cycling only, for homepage)
   * - 'orbit': Orbit around focus point (left-click drag, wheel zoom)
   * - 'fly': Free-flight with WASD (right-click look)
   * - 'both': Both modes available (default)
   */
  controlScheme?: ControlScheme;

  /**
   * Enable click-to-cycle camera poses.
   *
   * When true (default), clicking on the viewer cycles through predefined
   * camera poses from the document.json. Set to false for interactive
   * gallery mode where user controls should not be interrupted.
   */
  enablePoseCycling?: boolean;

  /**
   * Idle animation type.
   *
   * - 'none': No idle animation (user has full control immediately)
   * - 'drift-pause': Gentle hovering/drifting with pauses (default for homepage)
   * - 'auto-rotate': Continuous rotation around focus point
   *
   * Default: 'drift-pause'
   */
  idleAnimation?: IdleAnimationType;
}

const {
  scene,
  progressPosition = "center",
  progressOffsetX = 0,
  progressOffsetY = 0,
  previewSrc = `${import.meta.env.BASE_URL}/static/${scene}/preview.webp`,
  style: userStyle = "",
  controlScheme = "both",
  enablePoseCycling = true,
  idleAnimation = "drift-pause",
} = Astro.props as SplatProps;

/**
 * Environment toggle to disable splat rendering.
 * When DISABLE_SPLAT=true, a static preview image is shown instead of the WebGL viewer.
 * This is useful for development when the 3D viewer causes performance issues or crashes.
 */
const isSplatDisabled = import.meta.env.DISABLE_SPLAT === "true";
---

{isSplatDisabled ? (
  <!-- Disabled mode: Show static preview with overlay message -->
  <div
    class="splat-disabled"
    style={userStyle}
  >
    <img
      class="splat-disabled__preview"
      src={previewSrc}
      alt={`Preview of ${scene} scene`}
      decoding="async"
      loading="eager"
    />
    <div class="splat-disabled__overlay">
      <span class="splat-disabled__badge">3D Viewer Disabled</span>
      <span class="splat-disabled__hint">Set DISABLE_SPLAT=false in .env to enable</span>
    </div>
  </div>
) : (
  <astro-splat
    scene={scene}
    data-base={import.meta.env.BASE_URL}
    data-progress-position={progressPosition}
    data-control-scheme={controlScheme}
    data-enable-pose-cycling={enablePoseCycling.toString()}
    data-idle-animation={idleAnimation}
    style={`${userStyle}${userStyle ? ";" : ""} --progress-offset-x:${progressOffsetX}px; --progress-offset-y:${progressOffsetY}px;`}
  >
    <canvas></canvas>

    <!--
      DOM loader overlay:
      - A full-viewport overlay for the canvas with a glassy panel.
      - A linear progress bar with accessible semantics.
      - A concise percentage label placed directly beneath the bar.
    -->
    <div class="splat-loading" aria-live="polite" aria-busy="true">
      <!-- Scene preview shown while assets stream; kept under the panel -->
      <img
        class="splat-loading__preview"
        src={previewSrc}
        alt="Scene preview"
        decoding="async"
        loading="eager"
        fetchpriority="high"
        aria-hidden="true"
      />

      <div class="splat-loading__panel" role="group" aria-label="Loading 3D scene">
        <div class="splat-loading__bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
          <div class="splat-loading__fill" style="width:0%"></div>
        </div>

        <div class="splat-loading__label">
          <span class="splat-loading__percent">0%</span>
        </div>
      </div>
    </div>
  </astro-splat>
)}

<script>
  import { SuperSplatViewer } from "../script/splat/SuperSplatViewer";
  import { MIN_VIEWPORT_VISIBILITY_FOR_RENDER } from "@/constants/splat-viewer";
  import { SPLAT_EVT_LOADING_PROGRESS, SPLAT_EVT_LOADED, SPLAT_EVT_FIRST_FRAME } from "@/constants/splat-events";

  class AstroSplat extends HTMLElement {
    /** Reference to the viewer instance for cleanup. */
    private _viewer?: SuperSplatViewer;

    /** IntersectionObserver for visibility tracking. */
    private _intersectionObserver?: IntersectionObserver;

    /** Bound visibility change handler for cleanup. */
    private _visibilityHandler?: () => void;

    /** Bound page activity handler for cleanup. */
    private _pageActivityHandler?: () => void;

    /** List of activity events for cleanup. */
    private _activityEvents?: (keyof WindowEventMap)[];

    /** Bound scene load handler for cleanup. */
    private _sceneLoadHandler?: (event: Event) => void;

    /** Current scene name. */
    private _currentScene?: string;

    /** Base URL for assets. */
    private _base?: string;

    /** Current control scheme. */
    private _controlScheme?: "none" | "orbit" | "fly" | "both";

    /** Idle animation type. */
    private _idleAnimation?: "none" | "drift-pause" | "auto-rotate";

    connectedCallback() {
      // ======================
      // Element lookups
      // ======================
      const canvas = this.querySelector("canvas") as HTMLCanvasElement;
      const base = this.getAttribute("data-base") || "/";
      const controlScheme = (this.getAttribute("data-control-scheme") || "both") as "none" | "orbit" | "fly" | "both";
      const idleAnimation = (this.getAttribute("data-idle-animation") || "drift-pause") as
        | "none"
        | "drift-pause"
        | "auto-rotate";

      this._base = base;
      this._currentScene = this.getAttribute("scene") as string;
      this._controlScheme = controlScheme;
      this._idleAnimation = idleAnimation;

      // Loader DOM hooks
      const overlay = this.querySelector(".splat-loading") as HTMLElement | null;
      const panel = this.querySelector(".splat-loading__panel") as HTMLElement | null;
      const bar = this.querySelector(".splat-loading__bar") as HTMLElement | null;
      const fill = this.querySelector(".splat-loading__fill") as HTMLElement | null;
      const percentEl = this.querySelector(".splat-loading__percent") as HTMLElement | null;
      const previewImg = this.querySelector(".splat-loading__preview") as HTMLImageElement | null;

      // ======================
      // Viewer init (using new modular implementation)
      // ======================
      this._viewer = new SuperSplatViewer({
        canvas,
        scene: this._currentScene,
        sizeElement: this.parentElement as HTMLElement,
        base,
        controlScheme,
        idleAnimation,
      });

      // Click-to-advance (optional).
      // When enabled, clicking on the viewer cycles through predefined camera poses.
      // Disabled in gallery/showcase mode to allow uninterrupted user controls.
      const enablePoseCycling = this.getAttribute("data-enable-pose-cycling") !== "false";

      if (enablePoseCycling) {
        this.addEventListener("click", () => {
          console.debug("[Splat] click handler - dispatching splatviewer:active");

          // Dispatch splatviewer:active immediately when user clicks to cycle poses.
          // This is necessary because the state transition (idle → transitioning → idle)
          // doesn't emit 'splat:active' (only user control modes like orbit/fly do).
          // Without this, the hero content wouldn't hide when clicking to cycle.
          document.dispatchEvent(new CustomEvent("splatviewer:active"));

          this._viewer?.togglePose(1000);
        });
      }

      // ===== Event forwarding =====
      // Event forwarding from SuperSplatViewer to the global document.
      // This decouples the viewer from the page layout, allowing any
      // component on the page to react to viewer state changes.
      canvas.addEventListener("splat:active", () => {
        document.dispatchEvent(new CustomEvent("splatviewer:active"));
      });

      canvas.addEventListener("splat:idle", () => {
        document.dispatchEvent(new CustomEvent("splatviewer:idle"));
      });

      // ======================
      // Loader wiring
      // ======================
      if (overlay && panel && bar && fill && percentEl) {
        /**
         * Update visual width and accessible value.
         * @param {number} p0to100 Percent value clamped to [0..100].
         */
        const updateProgress = (p0to100: number) => {
          const clamped = Math.max(0, Math.min(100, p0to100 | 0));

          fill.style.width = clamped + "%";
          percentEl.textContent = clamped + "%";

          // Keep a11y attributes in sync with visuals (APG/MDN guidance).
          bar.setAttribute("aria-valuenow", String(clamped));
        };

        this.addEventListener(SPLAT_EVT_LOADING_PROGRESS, (e) => {
          const { percent } = (e as CustomEvent).detail || { percent: 0 };
          updateProgress(percent);
        });

        // Prepare to fade on load completion.
        this.addEventListener(SPLAT_EVT_LOADED, () => {
          overlay.classList.add("is-loaded");
        });

        // Fade out after first frame to avoid popping.
        this.addEventListener(SPLAT_EVT_FIRST_FRAME, () => {
          overlay.classList.add("is-finished");
          // Remove from hit-testing after transition ends.
          overlay.addEventListener(
            "transitionend",
            () => {
              overlay.style.display = "none";
              overlay.setAttribute("aria-busy", "false");
            },
            { once: true },
          );
        });
      }

      // Preview Image
      if (previewImg) {
        const ready = () => previewImg.classList.add("is-ready");

        if (previewImg.complete) {
          // Already in cache/decoded
          ready();
        } else {
          previewImg.addEventListener("load", ready, { once: true });
          previewImg.addEventListener("error", () => previewImg.classList.add("is-hidden"), { once: true });
        }
      }

      // ===== Scene switching support =====
      // Listen for scene load requests from the Showcase page or other components.
      // When a new scene is requested, we reload the page with the new scene.
      // This is the most reliable approach since the SuperSplatViewer creates
      // a PlayCanvas Application that's complex to properly reset.
      this._sceneLoadHandler = (event: Event) => {
        const customEvent = event as CustomEvent<{
          scene: string;
          controlScheme?: "none" | "orbit" | "fly" | "both";
        }>;
        const newScene = customEvent.detail?.scene;
        const newControlScheme = customEvent.detail?.controlScheme;

        if (newScene && newScene !== this._currentScene) {
          // For now, we'll use a simple approach: reload the viewer with the new scene.
          // This involves disposing the current viewer and creating a new one.
          this._loadScene(newScene, newControlScheme);
        }
      };

      this.addEventListener("splatviewer:load-scene", this._sceneLoadHandler);

      // ===== Viewport visibility: pause when < 60% visible =====
      // Use a low-overhead IntersectionObserver to compute intersection ratio.
      // Threshold array includes the exact cutoff, so we get callbacks when crossing it.
      this._intersectionObserver = new IntersectionObserver(
        (entries) => {
          const entry = entries[0];

          // entry.intersectionRatio ∈ [0,1]; pass to viewer to decide suspend/resume.
          this._viewer?.setViewportVisibility(entry.intersectionRatio);
        },
        { root: null, threshold: [0, MIN_VIEWPORT_VISIBILITY_FOR_RENDER] },
      );

      this._intersectionObserver.observe(this);

      // ===== Page Visibility: suspend when tab/page is hidden =====
      this._visibilityHandler = () => this._viewer?.notifyPageVisibility(document.hidden);
      document.addEventListener("visibilitychange", this._visibilityHandler, { passive: true });

      // Initialize once in case we mount hidden.
      this._visibilityHandler();

      // ===== Page Activity: resume idle animation on any page interaction =====
      // This replicates the old SplatCanvas behavior where any page activity
      // (mouse move, click, scroll, keyboard) would cause the drift animation
      // to resume, assuming the viewer is visible.
      //
      // Only set up these handlers if idle animation is enabled. When set to
      // 'none' (e.g., on the Showcase page), we don't want page activity to
      // constantly restart the idle animation and fight with user camera controls.
      if (idleAnimation !== "none") {
        this._pageActivityHandler = () => this._viewer?.notifyPageActivity();
        const activityEvents: (keyof WindowEventMap)[] = [
          "pointerdown",
          "pointermove",
          "wheel",
          "click",
          "keydown",
          "scroll",
        ];
        activityEvents.forEach((event) => {
          window.addEventListener(event, this._pageActivityHandler!, { passive: true });
        });
        // Store for cleanup
        this._activityEvents = activityEvents;
      }
    }

    /**
     * Load a new scene into the viewer.
     *
     * Disposes the current viewer and creates a new one with the specified scene.
     * Also resets the loading overlay to show progress for the new scene.
     *
     * @param scene Scene folder name to load
     * @param controlScheme Optional control scheme override for the new scene
     */
    private _loadScene(scene: string, controlScheme?: "none" | "orbit" | "fly" | "both"): void {
      // Get DOM elements
      const canvas = this.querySelector("canvas") as HTMLCanvasElement;
      const overlay = this.querySelector(".splat-loading") as HTMLElement | null;
      const fill = this.querySelector(".splat-loading__fill") as HTMLElement | null;
      const percentEl = this.querySelector(".splat-loading__percent") as HTMLElement | null;
      const bar = this.querySelector(".splat-loading__bar") as HTMLElement | null;
      const previewImg = this.querySelector(".splat-loading__preview") as HTMLImageElement | null;

      // Dispose the current viewer
      if (this._viewer) {
        this._viewer.dispose();
        this._viewer = undefined;
      }

      // Reset the loading overlay for the new scene
      if (overlay) {
        overlay.classList.remove("is-loaded", "is-finished");
        overlay.style.display = "block";
        overlay.setAttribute("aria-busy", "true");
      }

      if (fill) {
        fill.style.width = "0%";
      }

      if (percentEl) {
        percentEl.textContent = "0%";
      }

      if (bar) {
        bar.setAttribute("aria-valuenow", "0");
      }

      // Update preview image for the new scene
      if (previewImg && this._base) {
        previewImg.classList.remove("is-ready", "is-hidden");
        previewImg.src = `${this._base}static/${scene}/preview.webp`;

        // Set up load handler for new preview
        const ready = () => previewImg.classList.add("is-ready");

        if (previewImg.complete) {
          ready();
        } else {
          previewImg.addEventListener("load", ready, { once: true });
          previewImg.addEventListener("error", () => previewImg.classList.add("is-hidden"), { once: true });
        }
      }

      // Update the scene attribute and control scheme
      this.setAttribute("scene", scene);
      this._currentScene = scene;

      // Use the new control scheme if provided, otherwise keep the current one
      const effectiveControlScheme = controlScheme ?? this._controlScheme ?? "both";

      this._controlScheme = effectiveControlScheme;
      this.setAttribute("data-control-scheme", effectiveControlScheme);

      // Create a new viewer with the new scene.
      // Use the stored _idleAnimation value from the initial config.
      // This ensures scene switches maintain the same idle animation behavior.
      this._viewer = new SuperSplatViewer({
        canvas,
        scene,
        sizeElement: this.parentElement as HTMLElement,
        base: this._base!,
        controlScheme: effectiveControlScheme,
        idleAnimation: this._idleAnimation,
      });
    }

    disconnectedCallback() {
      // Clean up intersection observer
      if (this._intersectionObserver) {
        this._intersectionObserver.disconnect();
        this._intersectionObserver = undefined;
      }

      // Clean up visibility listener
      if (this._visibilityHandler) {
        document.removeEventListener("visibilitychange", this._visibilityHandler);
        this._visibilityHandler = undefined;
      }

      // Clean up page activity listeners
      if (this._pageActivityHandler && this._activityEvents) {
        this._activityEvents.forEach((event) => {
          window.removeEventListener(event, this._pageActivityHandler!);
        });
        this._pageActivityHandler = undefined;
        this._activityEvents = undefined;
      }

      // Clean up scene load handler
      if (this._sceneLoadHandler) {
        this.removeEventListener("splatviewer:load-scene", this._sceneLoadHandler);
        this._sceneLoadHandler = undefined;
      }

      // Dispose viewer
      if (this._viewer) {
        this._viewer.dispose();
        this._viewer = undefined;
      }
    }
  }

  customElements.define("astro-splat", AstroSplat);
</script>

<style>
  astro-splat {
    display: block;
    width: 100%;
    height: 100%;
    position: relative; /* contain overlay and panel */
  }

  /* =========================
   * Overlay shell
   * ========================= */
  .splat-loading {
    position: absolute;
    inset: 0;
    z-index: 1;

    /* Subtle scrim so preview remains visible */
    background: linear-gradient(180deg, rgba(8, 10, 14, 0.45), rgba(8, 10, 14, 0.32));
    backdrop-filter: blur(2px) saturate(120%);

    transition:
      opacity 260ms ease,
      transform 260ms ease;
    display: block;
  }

  .splat-loading.is-loaded {
    /* Slight micro-shrink to signal readiness pre-fade */
    transform: scale(0.995);
  }

  .splat-loading.is-finished {
    opacity: 0;
    transform: scale(0.985);
    pointer-events: none;
  }

  /* Preview image sits under the progress panel */
  .splat-loading__preview {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover; /* cover the overlay rect without distortion */
    object-position: center; /* keep subject centered */
    opacity: 0;
    transition: opacity 200ms ease;
    z-index: 0; /* panel is above by default */
    user-select: none;
    pointer-events: none;
    /* Apply a Gaussian blur to the preview. Use a CSS var for easy tuning. */
    filter: blur(var(--preview-blur-px, 12px));
    /* Slightly upscale to avoid visible transparent edges introduced by blur kernels. */
    transform: scale(1.06);
    /* Hint the browser that filter/transform may animate during the overlay’s life. Use sparingly. */
    will-change: filter, transform;
  }

  .splat-loading__preview.is-ready {
    opacity: 1;
  }

  .splat-loading__preview.is-hidden {
    display: none;
  }

  /* =========================
   * Panel layout and placement
   * ========================= */
  .splat-loading__panel {
    position: absolute;
    /* Default: center anchor */
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);

    /* 8-pt rhythm paddings and sizing */
    padding: 16px 18px;
    min-width: min(560px, 82%);
    max-width: 92%;

    /* Elegant glass panel */
    background: rgba(20, 23, 28, 0.52);
    border: 1px solid rgba(255, 255, 255, 0.12);
    border-radius: 14px;
    box-shadow:
      0 10px 30px rgba(0, 0, 0, 0.32),
      inset 0 0 0 1px rgba(255, 255, 255, 0.04);

    /* Stacking and transitions */
    transition:
      transform 220ms ease,
      opacity 220ms ease;

    /* Layout for bar and label */
    display: grid;
    grid-auto-flow: row;
    row-gap: 8px; /* label sits directly beneath bar */
  }

  /* Position presets (offsets via CSS vars) */
  astro-splat[data-progress-position="top-left"] .splat-loading__panel {
    left: var(--progress-offset-x, 0px);
    top: var(--progress-offset-y, 0px);
    transform: none;
  }
  astro-splat[data-progress-position="top-center"] .splat-loading__panel {
    left: 50%;
    top: var(--progress-offset-y, 0px);
    transform: translate(-50%, 0);
  }
  astro-splat[data-progress-position="top-right"] .splat-loading__panel {
    right: var(--progress-offset-x, 0px);
    top: var(--progress-offset-y, 0px);
    left: auto;
    transform: none;
  }
  astro-splat[data-progress-position="bottom-left"] .splat-loading__panel {
    left: var(--progress-offset-x, 0px);
    bottom: var(--progress-offset-y, 0px);
    top: auto;
    transform: none;
  }
  astro-splat[data-progress-position="bottom-center"] .splat-loading__panel {
    left: 50%;
    bottom: var(--progress-offset-y, 0px);
    top: auto;
    transform: translate(-50%, 0);
  }
  astro-splat[data-progress-position="bottom-right"] .splat-loading__panel {
    right: var(--progress-offset-x, 0px);
    bottom: var(--progress-offset-y, 0px);
    left: auto;
    top: auto;
    transform: none;
  }

  /* =========================
   * Determinate bar + label
   * ========================= */
  .splat-loading__bar {
    position: relative;
    width: 100%;
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.08));
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.18);
    overflow: hidden;
  }

  .splat-loading__fill {
    height: 100%;
    width: 0%;
    border-radius: inherit;
    /* Calm two-tone sheen; high-contrast on dark panel */
    background: linear-gradient(90deg, #7fb0ff, #0d6efd);
    box-shadow: 0 1px 4px rgba(13, 110, 253, 0.35);
    transition: width 120ms ease;
  }

  .splat-loading__label {
    /* Ensure AA contrast over the panel per WCAG */
    color: #eaf1ff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.45);
    font:
      600 0.95rem/1.2 system-ui,
      -apple-system,
      Segoe UI,
      Roboto,
      Ubuntu,
      "Helvetica Neue",
      Arial,
      "Noto Sans",
      "Apple Color Emoji",
      "Segoe UI Emoji";
    letter-spacing: 0.01em;
  }

  /* Respect reduced motion preferences (if anim rules expand later) */
  @media (prefers-reduced-motion: reduce) {
    .splat-loading,
    .splat-loading__panel,
    .splat-loading__fill .splat-loading__preview {
      transition: none;
    }
  }

  /* =========================
   * Disabled state placeholder
   * Shown when DISABLE_SPLAT=true
   * ========================= */
  .splat-disabled {
    display: block;
    width: 100%;
    height: 100%;
    position: relative;
    background: #0a0a0f;
  }

  .splat-disabled__preview {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    filter: blur(4px) saturate(80%);
    transform: scale(1.02);
    opacity: 0.7;
  }

  .splat-disabled__overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 8px;
    background: rgba(0, 0, 0, 0.4);
  }

  .splat-disabled__badge {
    padding: 8px 16px;
    background: rgba(255, 193, 7, 0.9);
    color: #1a1a1a;
    font-weight: 600;
    font-size: 0.875rem;
    border-radius: 6px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .splat-disabled__hint {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.75rem;
    font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, monospace;
  }
</style>
