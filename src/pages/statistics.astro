---
/**
 * statistics.astro
 *
 * Download statistics dashboard for LichtFeld Studio.
 * Showcases download metrics, growth trends, and release breakdowns
 * to demonstrate project traction for investors and users.
 *
 * Features:
 * - Key metric cards (total downloads, this month, latest release)
 * - Stacked area chart showing downloads by version
 * - Line chart showing cumulative growth
 * - Release breakdown table
 * - Contributors wall
 */
import Layout from "@/layouts/Layout.astro";
import { SITE } from "@/config/site.config";

// Stats components
import StatCard from "@/components/stats/StatCard.astro";
import TimeRangeSelector from "@/components/stats/TimeRangeSelector.astro";
import StackedAreaChart from "@/components/stats/StackedAreaChart.astro";
import PieChart from "@/components/stats/PieChart.astro";
import ReleaseTable from "@/components/stats/ReleaseTable.astro";

// Reuse contributors wall from homepage
import ContributorsWall from "@/components/contribute/ContributorsWall.astro";

// SEO metadata
const seoTitle = `Download Statistics | ${SITE.name}`;
const seoDescription = "Real-time download statistics and growth metrics for LichtFeld Studio. Track releases, monitor adoption, and see our growing community.";
---

<Layout title={seoTitle} description={seoDescription}>
    <!-- Hero Section with Key Metrics -->
    <section class="stats-hero">
        <div class="container px-4 py-5">
            <div class="stats-hero__header">
                <h1 class="stats-hero__title">Download Statistics</h1>
                <p class="stats-hero__subtitle">
                    Real-time metrics showing LichtFeld Studio adoption and growth
                </p>
            </div>

            <!-- Key Metric Cards -->
            <div class="stats-cards">
                <StatCard
                    label="Total Downloads"
                    icon="bi-download"
                    loading={true}
                />
                <StatCard
                    label="Last 30 Days"
                    icon="bi-calendar-range"
                    loading={true}
                />
                <StatCard
                    label="Latest Release"
                    icon="bi-tag"
                    loading={true}
                />
                <StatCard
                    label="Active Releases"
                    icon="bi-collection"
                    loading={true}
                />
            </div>
        </div>
    </section>

    <!-- Charts Row 1: Downloads by Version + Cumulative -->
    <section class="container px-4 py-4">
        <div class="stats-section__header">
            <h2 class="stats-section__title">Download Trends</h2>
            <TimeRangeSelector selected="daily" id="main-chart-range" />
        </div>

        <div class="stats-grid">
            <div class="stats-grid__item">
                <StackedAreaChart
                    id="cumulative-chart"
                    height={380}
                    title="Cumulative Downloads"
                />
            </div>

            <div class="stats-grid__item">
                <StackedAreaChart
                    id="downloads-chart"
                    height={380}
                    title="Downloads by Day"
                />
            </div>
        </div>
    </section>

    <!-- Charts Row 2: Version Adoption + Release Table -->
    <section class="container px-4 py-4">
        <div class="stats-grid">
            <div class="stats-grid__item">
                <PieChart
                    id="adoption-chart"
                    height={380}
                    title="Version Adoption"
                />
            </div>

            <div class="stats-grid__item">
                <ReleaseTable title="Release Breakdown" />
            </div>
        </div>
    </section>

    <!-- Data Attribution -->
    <section class="container px-4 py-3">
        <p class="stats-attribution">
            <i class="bi bi-info-circle"></i>
            Statistics are updated daily and reflect download counts from GitHub releases.
            Data shown is as of <span id="stats-as-of">loading...</span>
        </p>
    </section>

    <!-- Contributors Section -->
    <ContributorsWall title="Our Growing Community" />
</Layout>

<script>
    /**
     * Client-side data fetching and chart initialization.
     * Fetches stats from the API and dispatches events to components.
     */

    /**
     * API response types.
     */
    interface StatsResponse {
        asOf: string;
        totals: {
            allTime: number;
        };
        releases: Array<{
            tag: string;
            name: string;
            downloads: number;
            publishedAt: number | null;
            daily: Array<{ date: number; downloads: number }>;
            weekly: Array<{ week: number; downloads: number }>;
            monthly: Array<{ month: number; downloads: number }>;
        }>;
    }

    /**
     * Chart data point structure.
     */
    interface ChartDataPoint {
        x: number;
        y: number;
    }

    /**
     * Chart series structure.
     */
    interface ChartSeries {
        name: string;
        data: ChartDataPoint[];
    }

    /**
     * Current time range selection.
     */
    type TimeRange = "daily" | "weekly" | "monthly";

    let currentRange: TimeRange = "daily";
    let statsData: StatsResponse | null = null;

    /**
     * One day in milliseconds.
     */
    const ONE_DAY_MS = 24 * 60 * 60 * 1000;

    /**
     * Interpolates missing daily data points by distributing values evenly across gaps.
     * When data collection misses one or more days, this function fills in the gaps
     * with linearly interpolated cumulative values.
     *
     * @param dailyData - Array of daily cumulative snapshots (must be sorted by date ascending)
     * @returns Array with interpolated data points filling any gaps
     */
    function interpolateMissingDays(
        dailyData: Array<{ date: number; downloads: number }>
    ): Array<{ date: number; downloads: number }> {
        if (dailyData.length < 2) return dailyData;

        const result: Array<{ date: number; downloads: number }> = [];

        for (let i = 0; i < dailyData.length; i++) {
            const current = dailyData[i];

            result.push(current);

            // Check if there's a next point
            if (i < dailyData.length - 1) {
                const next = dailyData[i + 1];
                const daysBetween = Math.round((next.date - current.date) / ONE_DAY_MS);

                // If there's a gap of more than 1 day, interpolate
                if (daysBetween > 1) {
                    const downloadsDelta = next.downloads - current.downloads;
                    const dailyIncrement = downloadsDelta / daysBetween;

                    // Insert interpolated points for each missing day
                    for (let j = 1; j < daysBetween; j++) {
                        const interpolatedDate = current.date + j * ONE_DAY_MS;
                        const interpolatedDownloads = Math.round(current.downloads + dailyIncrement * j);

                        result.push({
                            date: interpolatedDate,
                            downloads: interpolatedDownloads,
                        });
                    }
                }
            }
        }

        return result;
    }

    /**
     * Formats a number with locale-aware separators.
     */
    function formatNumber(num: number): string {
        return new Intl.NumberFormat().format(num);
    }

    /**
     * Updates a StatCard with a new value.
     */
    function updateStatCard(index: number, value: number): void {
        const cards = document.querySelectorAll(".stat-card");
        const card = cards[index];

        if (!card) return;

        // Remove loading state
        card.classList.remove("stat-card--loading");

        // Update value
        const valueEl = card.querySelector(".stat-card__value");

        if (valueEl) {
            valueEl.innerHTML = formatNumber(value);
        }
    }

    /**
     * Parses a version string (e.g., "v1.2.3") into comparable numeric parts.
     */
    function parseVersion(tag: string): number[] {
        // Remove 'v' prefix and split by dots
        const match = tag.match(/v?(\d+)\.(\d+)\.(\d+)/);

        if (!match) return [0, 0, 0];

        return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
    }

    /**
     * Compares two version arrays. Returns negative if a < b, positive if a > b, 0 if equal.
     */
    function compareVersions(a: number[], b: number[]): number {
        for (let i = 0; i < 3; i++) {
            if (a[i] !== b[i]) {
                return a[i] - b[i];
            }
        }

        return 0;
    }

    /**
     * Transforms release data into chart series format showing DELTAS (new downloads per period).
     * Sorts releases so older versions are at the bottom of the stack
     * and newer versions are at the top (latest on top).
     *
     * Note: Daily data is stored as cumulative snapshots, so we calculate deltas.
     * Weekly/monthly data is already stored as deltas.
     */
    function transformToChartSeries(releases: StatsResponse["releases"], range: TimeRange): ChartSeries[] {
        // Sort releases by version: older first (bottom of stack), newer last (top of stack)
        const sortedReleases = [...releases].sort((a, b) => {
            const versionA = parseVersion(a.tag);
            const versionB = parseVersion(b.tag);

            return compareVersions(versionA, versionB);
        });

        return sortedReleases.map((release) => {
            let data: ChartDataPoint[];

            if (range === "daily") {
                // Daily data is cumulative snapshots - calculate deltas
                // First sort and interpolate any missing days
                const sorted = [...release.daily].sort((a, b) => a.date - b.date);
                const interpolated = interpolateMissingDays(sorted);

                // Skip first data point since we can't calculate delta without previous reference
                data = interpolated.slice(1).map((d, i) => {
                    const prevCount = interpolated[i].downloads; // i is offset by 1 due to slice
                    const delta = d.downloads - prevCount;

                    return { x: d.date, y: Math.max(0, delta) };
                });
            } else if (range === "weekly") {
                // Weekly data is already deltas
                data = release.weekly.map((d) => ({ x: d.week, y: d.downloads }));
            } else {
                // Monthly data is already deltas
                data = release.monthly.map((d) => ({ x: d.month, y: d.downloads }));
            }

            return {
                name: release.tag,
                data,
            };
        });
    }

    /**
     * Transforms release data into cumulative growth series.
     * Shows how total downloads have grown over time (monotonically increasing).
     * Sorts releases so older versions are at the bottom and newer versions are on top.
     *
     * Note: Daily data is already cumulative snapshots, so we use it directly.
     * Weekly/monthly data is stored as deltas, so we accumulate them.
     */
    function transformToCumulativeSeries(releases: StatsResponse["releases"], range: TimeRange): ChartSeries[] {
        // Sort releases by version: older first (bottom of stack), newer last (top of stack)
        const sortedReleases = [...releases].sort((a, b) => {
            const versionA = parseVersion(a.tag);
            const versionB = parseVersion(b.tag);

            return compareVersions(versionA, versionB);
        });

        // For each release, create a cumulative series (limit to top 5)
        return sortedReleases.slice(0, 5).map((release) => {
            let data: ChartDataPoint[];

            if (range === "daily") {
                // Daily data is already cumulative snapshots
                // Sort and interpolate any missing days for smooth visualization
                const sorted = [...release.daily].sort((a, b) => a.date - b.date);
                const interpolated = interpolateMissingDays(sorted);

                data = interpolated.map((d) => ({ x: d.date, y: d.downloads }));
            } else if (range === "weekly") {
                // Weekly data is deltas - accumulate them
                const sorted = [...release.weekly].sort((a, b) => a.week - b.week);
                let cumulativeTotal = 0;

                data = sorted.map((d) => {
                    cumulativeTotal += d.downloads;

                    return { x: d.week, y: cumulativeTotal };
                });
            } else {
                // Monthly data is deltas - accumulate them
                const sorted = [...release.monthly].sort((a, b) => a.month - b.month);
                let cumulativeTotal = 0;

                data = sorted.map((d) => {
                    cumulativeTotal += d.downloads;

                    return { x: d.month, y: cumulativeTotal };
                });
            }

            return {
                name: release.tag,
                data,
            };
        });
    }

    /**
     * Maps time range to display label for chart title.
     */
    const RANGE_LABELS: Record<TimeRange, string> = {
        daily: "Day",
        weekly: "Week",
        monthly: "Month",
    };

    /**
     * Updates all charts with data for the specified range.
     */
    function updateCharts(range: TimeRange): void {
        if (!statsData) return;

        // Update downloads chart title based on range
        const downloadsChartTitle = document.querySelector("[data-chart-id='downloads-chart']")
            ?.closest(".stacked-area-chart")
            ?.querySelector(".stacked-area-chart__title");

        if (downloadsChartTitle) {
            downloadsChartTitle.textContent = `Downloads by ${RANGE_LABELS[range]}`;
        }

        // Update downloads by version stacked area chart
        const downloadsChart = document.querySelector("[data-chart-id='downloads-chart']");

        if (downloadsChart) {
            const series = transformToChartSeries(statsData.releases, range);
            const event = new CustomEvent("chartdata", {
                detail: { series, granularity: range },
            });

            downloadsChart.dispatchEvent(event);
        }

        // Update cumulative downloads stacked area chart
        const cumulativeChart = document.querySelector("[data-chart-id='cumulative-chart']");

        if (cumulativeChart) {
            const series = transformToCumulativeSeries(statsData.releases, range);
            const event = new CustomEvent("chartdata", {
                detail: { series, granularity: range },
            });

            cumulativeChart.dispatchEvent(event);
        }
    }

    /**
     * Updates the release table with data.
     */
    function updateReleaseTable(): void {
        if (!statsData) return;

        const table = document.querySelector(".release-table");

        if (table) {
            const event = new CustomEvent("tabledata", {
                detail: {
                    releases: statsData.releases,
                    totalDownloads: statsData.totals.allTime,
                },
            });

            table.dispatchEvent(event);
        }
    }

    /**
     * Updates the version adoption pie chart.
     */
    function updateAdoptionChart(): void {
        if (!statsData) return;

        const pieChart = document.querySelector("[data-chart-id='adoption-chart']");

        if (pieChart) {
            // Sort releases by version (newest first for display)
            const sortedReleases = [...statsData.releases].sort((a, b) => {
                const versionA = parseVersion(a.tag);
                const versionB = parseVersion(b.tag);

                return compareVersions(versionB, versionA);
            });

            const labels = sortedReleases.map((r) => r.tag);
            const values = sortedReleases.map((r) => r.downloads);

            const event = new CustomEvent("chartdata", {
                detail: { labels, values },
            });

            pieChart.dispatchEvent(event);
        }
    }

    /**
     * Gets total downloads for the last 30 days.
     * Calculates from daily cumulative data by finding the difference
     * between the latest value and the value from ~30 days ago.
     */
    function getLast30DaysDownloads(releases: StatsResponse["releases"]): number {
        const now = Date.now();
        const thirtyDaysAgo = now - 30 * ONE_DAY_MS;

        let total = 0;

        releases.forEach((release) => {
            if (release.daily.length < 1) return;

            // Sort by date ascending
            const sorted = [...release.daily].sort((a, b) => a.date - b.date);

            // Get the latest cumulative value
            const latestValue = sorted[sorted.length - 1].downloads;

            // Find the value closest to 30 days ago (but not after it)
            let valueThirtyDaysAgo = 0;
            let foundDataPoint = false;

            for (let i = sorted.length - 1; i >= 0; i--) {
                if (sorted[i].date <= thirtyDaysAgo) {
                    valueThirtyDaysAgo = sorted[i].downloads;
                    foundDataPoint = true;
                    break;
                }
            }

            // If no data point before 30 days ago
            if (!foundDataPoint) {
                // If the release was published within the last 30 days, all downloads are within this period
                if (release.publishedAt && release.publishedAt > thirtyDaysAgo) {
                    valueThirtyDaysAgo = 0; // No downloads before the release existed
                } else {
                    // Release is older than 30 days but we don't have data going back that far
                    // Use the earliest available data point as a conservative estimate
                    valueThirtyDaysAgo = sorted[0].downloads;
                }
            }

            total += latestValue - valueThirtyDaysAgo;
        });

        return total;
    }

    /**
     * Returns the stats API URL based on environment.
     * Uses production API on localhost for development with real data.
     */
    function getStatsApiUrl(): string {
        const isLocalhost = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";

        return isLocalhost ? "https://lichtfeld.io/api/stats" : "/api/stats";
    }

    /**
     * Fetches stats data and initializes the dashboard.
     */
    async function initDashboard(): Promise<void> {
        try {
            // Fetch stats from API (uses production API on localhost)
            const response = await fetch(getStatsApiUrl());

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            statsData = await response.json() as StatsResponse;

            // Update stat cards
            updateStatCard(0, statsData.totals.allTime);
            updateStatCard(1, getLast30DaysDownloads(statsData.releases));

            // Latest release downloads (find by highest version number)
            if (statsData.releases.length > 0) {
                const latestRelease = statsData.releases.reduce((latest, current) => {
                    const latestVersion = parseVersion(latest.tag);
                    const currentVersion = parseVersion(current.tag);

                    return compareVersions(currentVersion, latestVersion) > 0 ? current : latest;
                }, statsData.releases[0]);

                updateStatCard(2, latestRelease.downloads);
            }

            // Active releases count
            updateStatCard(3, statsData.releases.length);

            // Update "as of" date
            const asOfEl = document.getElementById("stats-as-of");

            if (asOfEl) {
                asOfEl.textContent = new Date(statsData.asOf).toLocaleDateString(undefined, {
                    year: "numeric",
                    month: "long",
                    day: "numeric",
                });
            }

            // Initialize charts with default range
            updateCharts(currentRange);

            // Update release table
            updateReleaseTable();

            // Update adoption pie chart
            updateAdoptionChart();
        } catch (error) {
            console.error("Failed to fetch stats:", error);

            // Show error state
            const cards = document.querySelectorAll(".stat-card");

            cards.forEach((card) => {
                card.classList.remove("stat-card--loading");

                const valueEl = card.querySelector(".stat-card__value");

                if (valueEl) {
                    valueEl.textContent = "â€”";
                }
            });
        }
    }

    /**
     * Handles range change events from the TimeRangeSelector.
     */
    function handleRangeChange(event: CustomEvent): void {
        const { range } = event.detail;

        currentRange = range as TimeRange;
        updateCharts(currentRange);
    }

    // Initialize on DOM ready
    document.addEventListener("DOMContentLoaded", () => {
        initDashboard();

        // Listen for range changes
        document.addEventListener("rangechange", handleRangeChange as EventListener);
    });
</script>

<style>
    /**
     * Statistics Page Styles
     */

    /* Hero Section */
    .stats-hero {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-bottom: 1px solid var(--border-color);
    }

    .stats-hero__header {
        text-align: center;
        margin-bottom: 2rem;
    }

    .stats-hero__title {
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--color-text);
        margin-bottom: 0.5rem;
    }

    .stats-hero__subtitle {
        font-size: 1.125rem;
        color: #6c757d;
        max-width: 600px;
        margin: 0 auto;
    }

    /* Stat Cards Grid */
    .stats-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1.5rem;
        max-width: 1000px;
        margin: 0 auto;
    }

    /* Section Headers */
    .stats-section {
        margin-bottom: 2rem;
    }

    .stats-section__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1.5rem;
    }

    .stats-section__title {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--color-text);
        margin: 0;
    }

    /* Two-column Grid for Charts and Table */
    .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
    }

    .stats-grid__item--chart,
    .stats-grid__item--table {
        min-width: 0; /* Prevent grid blowout */
    }

    /* Attribution */
    .stats-attribution {
        font-size: 0.875rem;
        color: #6c757d;
        text-align: center;
        margin: 0;
    }

    .stats-attribution .bi {
        margin-right: 0.25rem;
    }

    /* Responsive Adjustments */
    @media (max-width: 991px) {
        .stats-grid {
            grid-template-columns: 1fr;
        }
    }

    @media (max-width: 767px) {
        .stats-hero__title {
            font-size: 2rem;
        }

        .stats-section__header {
            flex-direction: column;
            align-items: flex-start;
        }
    }

    @media (max-width: 576px) {
        .stats-cards {
            grid-template-columns: 1fr;
        }

        .stats-hero__title {
            font-size: 1.75rem;
        }
    }
</style>
